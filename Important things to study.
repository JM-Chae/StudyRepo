This memo is compiled based on the lecture given by ‘Heejo’ on November 9, 24.



@대전제
좋은 개발자가 되기 위해서 가장 중요한 기본 소양은 CT - 컴퓨팅 사고력이다.
컴퓨팅 사고력은, 어떠한 문제에 직면했을 때 이를 컴퓨터가 효과적으로 수행할 수 있도록 문제에 접근하여 해결 방법을 도출해내는 과정.
개발자는 결국 어떠한 문제를 소프트웨어적으로 해결하는 직업이기 때문. 단순히 해당 문제를 해결하는 코드를 작성하는 일에 그치지 않고, 그 문제에 깔린 '상황에 맞게 처리'하는 것이 주된 목표. 따라서, 오답은 있어도 정답이라는 건 없다.

@백, 프론트
프론트 -> 유저와의 밀접한 관계를 가짐. 서비스의 질을 담당함.
백 -> 서비스의 양을 담당함.
         스케일 아웃(서버를 증설:로드 밸런싱; 병목 현상에 대한 해결책), 스케일 업(비용적 문제, 하드웨어적 한계)


@객체지향 by 객체지향의 사실과 오해
객체지향은 현실 세계에 대한 모방이다?; 역할, 책임, 협력
희조좌曰; 나눌 수 있는 것(나눌 기준) -> 객체지향의 종착점은 결국 MSA(Micro-Service Architecture)
객체지향이 결국 후술할 모든 것에 있어서 지대한 영향을 끼침.

- 백엔드 개발자가 고려해야 할 3가지     ?서킷브레이커; 절체기라고 이해하고 넘어가면 될 듯.
	1. 유지보수 [ 리팩토링, 개선, 추가 등 ]
	2. 양(트래픽) -> 애플리케이션 자체의 병목 현상, 시간 복잡도
	   저수준: 개발자가 제어할 수 없는 로우 레벨; DB 같은 것(이해 숙지 필요).
	   고수준: 성능에 영향을 끼칠 수 있는 것; 캐싱과 병렬성(멀티 스레드(자바, 코틀린))
	3. 외부 API 대응 ?

- 자바 진영 스프링이 주로 사용되는 이유는 스프링이 당초 대용량을 처리하기 위한, 객체지향을 서포트하는 프레임워크이기 때문.

@희조좌가 생각하는 공부 최적의 루트
역시 CT를 키운다는 마음가짐으로 임해야 함 -> CS, 알고리즘

- 알고리즘을 공부할 때 보상심리에 빠질 수 있음에 유념.
  수학 문제와 같다고 생각할 것. 개념과 공식에 익숙해지는 것이 최우선.
  개념을 먼저 공부하고, 문제를 많이 풀어 볼 것.
  문제를 보았을 때 알고리즘이 떠오르지 않으면 개념이 부족한 것.

- 프레임워크는 별로 선행학습이 중요하지 않다. 필요로 할 때 공부하면 됨.

- 언어 공부
  표현하는 방식은 틀려도 결국 모든 언어는 주어진 문제 해결이라는 공통된 목적을 가지고 있음.
  공식 문서를 파는 것이 대기만성의 길이긴 하나, 취준 단계에서는 어울리지 않을 수 있음.
  키워드를 토대로 찾아 공부할 수 있는 능력을 기르면 좋다.
  직접 코드를 적어 보며 공부하는 것이 좋다.
  주어진 상황에 맞는 코드를 작성하는 문제 해결력이 중요함; 레거시 -> 작성 당시 이유 관계를 갖는 코드.

@목적성?
3스텝
1. 치즈(빈 공간이 뚫린) 덩어리를 생성함. 빠르게 ~~~ 이런 게 있구나 ~~~ 하는 식으로 훑는 작업.
2. 빈 공간을 매꾸어 가는 것. 
3. 기반, 기능적 구조를 뜯어 동작 원리 파악 - 투머치

@협업에 있어서 중요한 요소.
개발자는 개발자이기 전에 사람이기 때문에, 각자의 성향이 다르다. 따라서 그 다름을 상호 존중하는 자세가 필요함.

@大前提
良き開発者になるために最も重要な基本素養はCT-コンピューティング思考力だ。
コンピューティング思考力は、ある問題に直面したときにこれをコンピュータが効果的に解決できるようにその問題にアプローチして解決方法を導き出す過程。
開発者は結局、ある問題をソフトウェア的に解決する職業だからだ。 単に当問題を解決するコードを作成することにとどまらず、その問題に下敷きとなった「状況に応じて処理」することが主な目標。 したがって、誤答はあっても正解というものはない。

@バック、フロント
フロント -> ユーザーとの密接な関係を持つ。 サービスの質を担当する。
バック -> サービスの量を担当する。
スケールアウト（サーバー増設:ロードバランシング;ボトルネック現象の解決策）、スケールアップ（コスト的問題、ハードウェア的限界）


@オブジェクト指向 by オブジェクト指向の事実と誤解(書籍)
オブジェクト指向は現実世界に対する模倣であるか？; 役割、責任、協力
Heejo曰; 分けられるもの(分ける基準)-> オブジェクト指向の終着点は結局MSA(Micro-Service Architecture)
オブジェクト指向が最終的に後述する全てのものにおいて多大な影響を与える。

- バックエンドの開発者が考慮すべき3つ            ？サーキットブレーカー; 切替器と認識していいと思う。
1. メンテナンス[リファクタリング、改善、追加など]
2. 量(トラフィック) -> アプリケーション自体のボトルネック、Time Complexity
低レベル:開発者が制御できないローレベル; DB のようなもの（理解、熟知が必要）。
高レベル:性能に影響を及ぼす可能性のあるもの; キャッシングと並列性(マルチスレッド(JAVA、Kotlin))
3. 外部API対応？

- JAVA陣営でSpringが主に使われる理由は、Springが当初大容量を処理するための、オブジェクト指向をサポートするフレームワークであるため。

@Heejoさんが考える勉強最適のルート
やはりCTを育てるという心構えで臨まなければならない->CS、アルゴリズム

- アルゴリズムを勉強するとき、補償心理に陥る可能性があることに留意。
数学の問題と同じだと思うこと。 概念と公式に慣れることが最優先。
概念をまず勉強して、問題をたくさん解いてみること。
問題を見た時、アルゴリズムが思い浮かばないと概念が足りないことになる。

- フレームワークはあまり先行学習が重要ではない。 必要な時に勉強すればいい。

- 言語の勉強
表現の仕方は別々でも結局すべての言語は与えられた問題の解決という共通の目的を持っている。
公式文書を網羅することが大器晩成の道ではあるが、就活段階では似合わないだろう。
キーワードをベースに探して勉強できる能力を育てれば良い。
直接コードを書いてみて勉強した方が良い。
与えられた状況に合ったコードを作成する問題解決力が重要である; レガシー -> 作成当時、理由関係を持つコード。

@目的性？
3ステップ
1. チーズの塊(穴が開いている)を作る。 素早く、こういうのがあるんだ~~っていうふうに目を通す作業。
2. 空いたスペースを埋めること。
3. 基盤、機能的構造を一つずつ解体して動作原理を把握 - これはやりすぎかもしれない。

@協業における重要な要素。
開発者は開発者である前に人であるため、各自の個性を持つ。 したがって、その個性を相互尊重する姿勢が必要。
